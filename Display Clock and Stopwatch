ORG 8100H;

MOV TMOD,#01 ;TIMER 0, MODE 1 ( 16 BIT MODE )
MOV B, #10;
MOV A, #10H;
MOV DPTR, #0E803H;
MOV A, #10000001B; // CONTROL WORD TO SET I/O OPERATIONS ACTIVE AND SETTING PORT A AS OUTPUT
MOVX @DPTR, A;

// CHECK BUTTON STATE
MOV R7, #00H;
// THE NEXT SECTION ALLOCATES THE CONTROL SIGNALS REQUIRED TO DISLPAY DIGITS IN THE 7-SEGMENT DISPLAY
MOV DPTR, #9000H;

COUNT_TO_DISPLAY: // STORING THE SIGNALS TO BE GENERATED IN THE OUTPUT TO DISPLAY SPECIFIC DIGITS
	MOV A, #10111111B;
	MOVX @DPTR, A;
	INC DPTR;
	MOV A, #10000110B;
	MOVX @DPTR, A;
	INC DPTR;
	MOV A, #11011011B;
	MOVX @DPTR, A;
	INC DPTR;
	MOV A, #11001111B;
	MOVX @DPTR, A;
	INC DPTR;
	MOV A, #11100110B;
	MOVX @DPTR, A;
	INC DPTR;
	MOV A, #11101101B;
	MOVX @DPTR, A;
	INC DPTR;
	MOV A, #11111101B;
	MOVX @DPTR, A;
	INC DPTR;
	MOV A, #10000111B;
	MOVX @DPTR, A;
	INC DPTR;
	MOV A, #11111111B;
	MOVX @DPTR, A;
	INC DPTR;
	MOV A, #11101111B;
	MOVX @DPTR, A;
// MEMORY ALLOCATION COMPLETED


;// ALLOCATING THE STARTING TIME FOR CLOCK AND STOPWATCH
ASSIGN_CLOCK: ;// STORING THE STARTING TIME OF CLOCK
	MOV DPTR, #9010H;
	MOV A, #12; // FOR HRS
	MOVX @DPTR, A;
	INC DPTR;
	MOV A, #55; // FOR MINUTES
	MOVX @DPTR, A;
	INC DPTR;
	MOV A, #43; // FOR SECONDS
	MOVX @DPTR, A;
	
ASSIGN_STOPWATCH: ;// STORING THE STARTING TIME OF STOPWATCH
	MOV DPTR, #9013H;
	MOV A, #00H; // FOR HRS
	MOVX @DPTR, A;
	INC DPTR;
	MOV A, #00H; // FOR MINUTES
	MOVX @DPTR, A;
	INC DPTR;
	MOV A, #00; // FOR SECONDS
	MOVX @DPTR, A;
	
;// CLOCK AND STOPWATCH MEMORY ALLOCATION COMPLETED
	
	;DO:
		;ACALL CHECK_1_BIT;
		;MOV DPTR, #0E800H;
		;MOVX @DPTR, A;
		;SJMP DO;

;// THE CLOCK IMPLEMENTATION STARTS HERE
MOV A, #00H;
ACALL CHECK_1_BIT;
CJNE A, #00H, LETS_DO_IT_STOPWATCH;
SJMP LETS_DO_IT_CLOCK;

LETS_DO_IT_CLOCK:
	ACALL RESET_STOPWATCH;
	ACALL ALLOCATE_CLOCK;
	ACALL DELAY;
	ACALL UPDATE_SEC;
	ACALL CHECK_1_BIT;
	CJNE A, #00H, LETS_DO_IT_STOPWATCH;
	SJMP LETS_DO_IT_CLOCK;
	
LETS_DO_IT_STOPWATCH:
	ACALL CHECK_2_BIT;
	CJNE A, #04H, END_;
	SJMP START;
	ACALL CHECK_1_BIT;
	CJNE A, #00H, LETS_DO_IT_STOPWATCH;
	SJMP LETS_DO_IT_CLOCK;

CHECK_1_BIT:
	MOV DPTR, #0E802H;
	MOVX A, @DPTR;
	ANL A, #01H;
	RET;

CHECK_2_BIT:
	MOV DPTR, #0E802H;
	MOVX A, @DPTR;
	ANL A, #06H;
	RET;

START:
	ACALL ALLOCATE_STOPWATCH;
	ACALL DELAY;
	ACALL UPDATE_STOPWATCH_SEC;
	ACALL UPDATE_SEC;
	ACALL CHECK_1_BIT;
	CJNE A, #01H, LETS_DO_IT_CLOCK;
	ACALL CHECK_2_BIT;
	CJNE A, #04H, END_;
	SJMP START;

END_:
	ACALL ALLOCATE_STOPWATCH;
	ACALL DELAY;
	ACALL UPDATE_SEC;
	ACALL CHECK_1_BIT;
	CJNE A, #01H, LETS_DO_IT_CLOCK;
	ACALL CHECK_2_BIT;
	CJNE A, #04H, END_;
	SJMP START;

UPDATE_SEC: ;// TO UPDATE SECONDS
	MOV DPTR, #9012H;
	MOVX A, @DPTR;
	INC A; // THE SECOND IS INCREASED BY 1 WHENEVER THIS FUNCTION IS CALLED.
	CJNE A, #60, UPDATE_DPTR; 
	MOV A, #00H; RESET THE SECONDS TO 00 WHEN 60 SECONDS ARE COMPLETED
	MOVX @DPTR, A;
	SJMP UPDATE_MIN; TO UPDATE MINUTES WHEN 60 SECONDS ARE COMPLETED


UPDATE_MIN:  ;// TO UPDATE MINUTES
	MOV DPTR, #9011H;
	MOVX A, @DPTR;
	INC A; // THE MINUTE IS UPDATED WHEN THE FUNCTION IS CALLED BY UPDATE_SECS FUNCTION
	CJNE A, #60, UPDATE_DPTR; UNTIL 60 MINUTES ARE OVER, CONTINUE UPDATING DPTR
	MOV A, #00H; 
	MOVX @DPTR, A; IF 60 MINUTES ARE OVER, RESET MINUTES TO 00 AND UPDATE HRS NEXT
	SJMP UPDATE_HRS; 
	

UPDATE_HRS: ;// TO UPDATE HRS
	MOV DPTR, #9012H;
	MOV A, #00H;
	MOVX @DPTR, A;
	MOV DPTR, #9011H;
	MOV A, #00H;
	MOVX @DPTR, A;
	MOV DPTR, #9010H;
	MOVX A, @DPTR;
	INC A;
	CJNE A, #24, UPDATE_DPTR;
	SJMP INIT; WHEN 24 HRS ARE COMPLETED INITIALISE THE CLOCK TO 00 00 00 

UPDATE_DPTR: ;// TO UPDATE DPTR
	MOVX @DPTR, A;
	RET;
	
INIT: // TO INITIALISE THE CLOCK TO 00 00 00
	MOV DPTR, #9010H;
	MOV A, #00;
	MOVX @DPTR, A;
	INC DPTR;
	MOVX @DPTR, A;
	INC DPTR;
	MOVX @DPTR, A;
	RET
	

	
UPDATE_STOPWATCH_SEC: ;// TO UPDATE SECONDS
	MOV DPTR, #9015H;
	MOVX A, @DPTR;
	INC A; // THE SECOND IS INCREASED BY 1 WHENEVER THIS FUNCTION IS CALLED.
	CJNE A, #60, UPDATE_DPTR; 
	MOV A, #00H; RESET THE SECONDS TO 00 WHEN 60 SECONDS ARE COMPLETED
	MOVX @DPTR, A;
	SJMP UPDATE_STOPWATCH_MIN; TO UPDATE MINUTES WHEN 60 SECONDS ARE COMPLETED

RESET_STOPWATCH:
	MOV DPTR, #9013H;
	MOV A, #00H; // FOR HRS
	MOVX @DPTR, A;
	INC DPTR;
	MOV A, #00H; // FOR MINUTES
	MOVX @DPTR, A;
	INC DPTR;
	MOV A, #00; // FOR SECONDS
	MOVX @DPTR, A;
	RET;

UPDATE_STOPWATCH_MIN:  ;// TO UPDATE MINUTES
	MOV DPTR, #9014H;
	MOVX A, @DPTR;
	INC A; // THE MINUTE IS UPDATED WHEN THE FUNCTION IS CALLED BY UPDATE_SECS FUNCTION
	CJNE A, #60, UPDATE_DPTR; UNTIL 60 MINUTES ARE OVER, CONTINUE UPDATING DPTR
	MOV A, #00H; 
	MOVX @DPTR, A; IF 60 MINUTES ARE OVER, RESET MINUTES TO 00 AND UPDATE HRS NEXT
	SJMP UPDATE_STOPWATCH_HRS; 
	

UPDATE_STOPWATCH_HRS: ;// TO UPDATE HRS
	MOV DPTR, #9013H;
	MOV A, #00H;
	MOVX @DPTR, A;
	MOV DPTR, #9014H;
	MOV A, #00H;
	MOVX @DPTR, A;
	MOV DPTR, #9015H;
	MOVX A, @DPTR;
	INC A;
	CJNE A, #24, UPDATE_DPTR;
	SJMP INIT_STOPWATCH; WHEN 24 HRS ARE COMPLETED INITIALISE THE CLOCK TO 00 00 00 

	
INIT_STOPWATCH: ;// TO INITIALISE THE CLOCK TO 00 00 00
	MOV DPTR, #9010H;
	MOV A, #00;
	MOVX @DPTR, A;
	INC DPTR;
	MOVX @DPTR, A;
	INC DPTR;
	MOVX @DPTR, A;
	RET

;// TO ASSIGN THE DIGITS TIME POINTERS TO CORRESPONDING REGISTERS
ALLOCATE_CLOCK: ;// FUNCTION TO ALLOCATE THE VALUES OF CORRESPONDING DIGITS TO THE REGISTERS FROM MEMORY
	MOV B, #10;
	MOV DPTR, #9012H;
	MOVX A, @DPTR;
	DIV AB; TAKE VALUE FROM THE SECONDS REGISTER. OBTAIN R0 AND R1 FROM THE STORED VALUE BY DIVISION AND MODULO OPERATION
	MOV R0, A; R0 REPRESENTS THE 10S DIGIT OF SECONDS COUNTER WHILE R1 REPRESENTS THE 0S DIGIT.
	MOV A, B; THE SAME IS DONE FOR MINUTES AND HRS
	MOV R1, A;
	MOV B, #10;
	MOV DPTR, #9011H; 
	MOVX A, @DPTR;
	DIV AB;
	MOV R2, A;
	MOV A, B;
	MOV R3, A;
	MOV B, #10;
	MOV DPTR, #9010H;
	MOVX A, @DPTR;
	DIV AB;
	MOV R4, A;
	MOV A, B;
	MOV R5, A;
	MOV B, #10;
	RET;

ALLOCATE_STOPWATCH: ;// FUNCTION TO ALLOCATE THE VALUES OF CORRESPONDING DIGITS TO THE REGISTERS FROM MEMORY
	MOV B, #10;
	MOV DPTR, #9015H;
	MOVX A, @DPTR;
	DIV AB; TAKE VALUE FROM THE SECONDS REGISTER. OBTAIN R0 AND R1 FROM THE STORED VALUE BY DIVISION AND MODULO OPERATION
	MOV R0, A; R0 REPRESENTS THE 10S DIGIT OF SECONDS COUNTER WHILE R1 REPRESENTS THE 0S DIGIT.
	MOV A, B; THE SAME IS DONE FOR MINUTES AND HRS
	MOV R1, A;
	MOV B, #10;
	MOV DPTR, #9014H; 
	MOVX A, @DPTR;
	DIV AB;
	MOV R2, A;
	MOV A, B;
	MOV R3, A;
	MOV B, #10;
	MOV DPTR, #9013H;
	MOVX A, @DPTR;
	DIV AB;
	MOV R4, A;
	MOV A, B;
	MOV R5, A;
	MOV B, #10;
	RET;
;// THE CORRESPONDING ALLOCATION TO THE REGISTER ENDS HERE

;// THE DELAY FUNCTION STARTS HERE
;// THE DELAY FUNCTION DOES TWO THINGS
;// 1ST - IT CREATES A DELAY OF APPROXIMATELY 1 SEC
;// 2ND - IT GLOWS THE 6 (7 - SEGMENT) DISPLAYS ALTERNATELY
DELAY:
	MOV R6, #00H;
	MOV A, #11111110B;

DELAY2:
	MOV TL0,#8CH; SET LOWER BYTE OF TIMER TO 00
	MOV TH0,#0F8H; SET HIGHER BYTE OF TIMER TO 00
	ACALL HERE;
	// AFTER THE HERE FUNCTION IS CALLED IT CREATES A SMALL DELAY T
	CJNE R6, #0FFH, DELAY2; 
	// THE SMALL DELAY IS PRODUCED 256 TIMES AND T IS SUCH THAT (256*T ~ 1 SECOND)
	RET;

HERE:
	SETB TR0; SET THE TIMER 0

AGAIN:
	JNB TF0,AGAIN;
	ACALL ALTERNATE_RUN; // THIS FUNCTION IS USED TO CREATE ALTERNATION BETWEEN ACTIVATING 7-SEGMENT LEDS
	CLR TR0; CLEAR THE TIMER
	CLR TF0; CLEAR THE TIMER FLAG
	INC R6;
	RET;

ALTERNATE_RUN: 
	MOV DPTR, #0E801H; // ACCESINFG PORT B
	MOVX @DPTR, A; 
	SJMP SET_1ST; 
	COME_HERE:
		RET;

SET_1ST: ;// FOR ACCESING THE ONES DIGIT OF THE SECONDS DISPLAY
	CJNE A, #11111110B, SET_2ND; // IF A IS NOT #11111110B THEN GO TO SET_2ND
	MOV DPTR, #9000H;
	MOV A, R0; 
	MOV DPL, A;
	MOVX A, @DPTR; // ACCESINFG THE CONTROL SIGNALS TO DISPLAY DIGIT STORED IN R0
	MOV DPTR, #0E800H;
	MOVX @DPTR, A;
	MOV A, #11111101B; // SET A FOR ACTIVATING THE 2ND 7-SEGMENT DISPLAY
	SJMP COME_HERE;

SET_2ND: ;// FOR ACCESING THE TENS DIGIT OF THE SECONDS DISPLAY
	CJNE A, #11111101B, SET_3RD; // IF A IS NOT #11111101B THEN GO TO SET_3RD
	MOV DPTR, #9000H;
	MOV A, R1;
	MOV DPL, A;
	MOVX A, @DPTR; // ACCESINFG THE CONTROL SIGNALS TO DISPLAY DIGIT STORED IN R1
	MOV DPTR, #0E800H;
	MOVX @DPTR, A;
	MOV A, #11111011B; // SET A FOR ACTIVATING THE 3RD 7-SEGMENT DISPLAY
	SJMP COME_HERE;

SET_3RD: ;// FOR ACCESING THE ONES DIGIT OF THE MINUTES DISPLAY
	CJNE A, #11111011B, SET_4TH; // IF A IS NOT #11111011B THEN GO TO SET_2ND
	MOV DPTR, #9000H;
	MOV A, R2;
	MOV DPL, A;
	MOVX A, @DPTR; // ACCESINFG THE CONTROL SIGNALS TO DISPLAY DIGIT STORED IN R2
	MOV DPTR, #0E800H;
	MOVX @DPTR, A;
	MOV A, #11110111B; // SET A FOR ACTIVATING THE 4TH 7-SEGMENT DISPLAY
	SJMP COME_HERE;

SET_4TH: ;// FOR ACCESING THE TENS DIGIT OF THE MINUTES DISPLAY
	CJNE A, #11110111B, SET_5TH; // IF A IS NOT #11110111B THEN GO TO SET_2ND
	MOV DPTR, #9000H;
	MOV A, R3;
	MOV DPL, A;
	MOVX A, @DPTR; // ACCESINFG THE CONTROL SIGNALS TO DISPLAY DIGIT STORED IN R3
	MOV DPTR, #0E800H;
	MOVX @DPTR, A;
	MOV A, #11101111B; // SET A FOR ACTIVATING THE 5TH 7-SEGMENT DISPLAY
	SJMP COME_HERE;

SET_5TH: ;// FOR ACCESING THE ONES DIGIT OF THE HRS DISPLAY
	CJNE A, #11101111B, SET_6TH; // IF A IS NOT #11101111B THEN GO TO SET_2ND
	MOV DPTR, #9000H;
	MOV A, R4;
	MOV DPL, A;
	MOVX A, @DPTR; // ACCESINFG THE CONTROL SIGNALS TO DISPLAY DIGIT STORED IN R4
	MOV DPTR, #0E800H;
	MOVX @DPTR, A;
	MOV A, #11011111B; // SET A FOR ACTIVATING THE 6TH 7-SEGMENT DISPLAY
	SJMP COME_HERE;

SET_6TH: ;// FOR ACCESING THE TENS DIGIT OF THE HRS DISPLAY
	CJNE A, #11011111B, COME_HERE; // IF A IS NOT #11011111B THEN GO TO SET_2ND
	MOV DPTR, #9000H;
	MOV A, R5;
	MOV DPL, A;
	MOVX A, @DPTR; // ACCESINFG THE CONTROL SIGNALS TO DISPLAY DIGIT STORED IN R5
	MOV DPTR, #0E800H;
	MOVX @DPTR, A;
	MOV A, #11111110B; // SET A FOR ACTIVATING THE 1ST 7-SEGMENT DISPLAY
	SJMP COME_HERE;
	
;// THE DELAY FUNCTION ENDS HERE
	
INF_LOOP:
	SJMP INF_LOOP

END
