ORG 8100H

MOV DPTR, #9000H;
MOV R0, #100;

ASSIGN:
	MOV A, R0;
	MOVX @DPTR, A;
	INC DPTR;
	DJNZ R0, ASSIGN;

MOV A, #00H;
MOVX @DPTR, A;
INC DPTR;
MOVX @DPTR, A;

;Sorting using bubble sort


MOV R0,#100
OUTER_LOOP:
	MOV R1, #99
	MOV DPTR, #9000H
	INNER_LOOP:
		MOVX A, @DPTR
		MOV R3,A
		INC DPTR
		MOVX A, @DPTR
		MOV R4,A
		MOV R6,A
		MOV A,R3
		SUBB A,R6
		JC NEXT_TO_SWAP
SWAP___:
	MOV A, R6
	DEC DPL
	MOVX @DPTR,A
	MOV A,R3
	INC DPTR
	MOVX @DPTR,A
NEXT_TO_SWAP:
	DJNZ R1,INNER_LOOP
	DJNZ R0, OUTER_LOOP

INITBIN:
	MOV A, #34H
	MOV DPTR, #9500H
	MOVX @DPTR, A
	MOV R0, A       ; MOVE INTO R0 FOR COMPARISON
	
	MOV DPTR, #9000H ; START OF THE ARRAY
	MOV R1, #0       ; LOWER LIMIT
	MOV R2, #100     ; UPPER LIMIT
				
WILLMIDCHANGE: ; CHECKS IF THE MIDDLE VALUE WILL CHANGE, IF NOT ENDS THE PROGRAM BECAUSE SEARCH ;VALUE DOES NOT EXIST
	MOV A, R2
	SUBB A, R1 ; SUBTRACT R2 FROM ACCUMULATOR, IF THE DIFFERENCE IS < 1, THE DPL WILL NOT CHANGE, AND THE SEARCH VALUE IS NOT FOUND
	
	JZ NOTFOUND
	
	MOV A, R2
	ADD A, R1  ; ACC HAS R1 + R2
	MOV B, #2  ; DIVIDE BY 2 TO GET (R1 + R2) / 2
	DIV AB
	
	MOV DPL, A
				
BINCMP:
	MOVX A, @DPTR
	SUBB A, R0    ; SUBTRACT CURRENT VALUE CHECKED FROM THE VALUE TO BE SEARCHED
	
	JZ FOUND      ; IF THEY ARE EQUAL, A WILL BE 0
	
	JC BINHIGHER   ; IF THE SEARCH VALUE IS SMALLER, GO TO BINLOWER
	JNC BINLOWER ; IF THE SEARCH VALUE IS LARGER, GO TO BINHIGHER
	
BINLOWER:
	MOV R2, DPL ; BRING THE UPPER LIMIT DOWN
	JMP WILLMIDCHANGE

BINHIGHER:
	MOV R1, DPL ; BRING THE LOWER LIMIT UP
	JMP WILLMIDCHANGE
	
FOUND: ; THE VALUE AT DPTR IS THE ONE TO BE FOUND, INDEX IS THEREFORE DPL
	MOV A, DPL       ; MOVE INDEX INTO ACC
	MOV DPTR, #9550H ; @9550H IS WHERE THE INDEX SHOULD BE WRITTEN
	MOVX @DPTR, A    ; WRITE IT
	JMP PROGEND

NOTFOUND:
	MOV DPTR, #9550H ; @9550H IS WHERE THE INDEX SHOULD BE WRITTEN
	MOV A, #-1
	MOVX @DPTR, A    ; PUT -1 THERE
	JMP PROGEND

PROGEND:
	JMP PROGEND ; Infinite loop to prevent the next code from running
END
